# -*- coding: utf-8 -*-
"""circular_OrgbyMechConf_Jan24_FONTSIZE_PaperFig.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UAFUogTu-tK4Cb6oiVSLNaPxePSljG2r
"""

# Header
# Sebastian Lopez
# Circular plot organized by mechanical state of the exp configuration
# Aug 15, 2023
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import io

# INSTRUCTIONS - > UPLOAD "MehcanicalConf.csv" and modify group size in each section

#Changegs Aug 23
# Font type
# import file code

# set the font globally

# choose between:  ‘serif’, ‘sans-serif’, ‘cursive’, ‘fantasy’, and ‘monospace’
# https://datascienceparichay.com/article/change-font-type-in-matplotlib-plots/

plt.rcParams.update({'font.family':'serif'})
# the current font family
print(plt.rcParams['font.family'])
# list of fonts in sans-serif
plt.rcParams['font.serif']

# change fontsize jan 2024
plt.rc('font', size=16)

# this code has a glitch not used
# set the font name for a font family

#plt.rcParams.update({'font.sans-serif':'Helvetica'})

# import dataset
from google.colab import files
uploaded = files.upload()

# this used to work in Sep 22 now it is not working dont know why
df = pd.read_csv(io.StringIO(uploaded['MechanicalConf_NewCat7_PaperFig.csv'].decode('utf-8')))

#df = pd.read_csv('MechanicalConf_NewCat.csv')

# file loadingg has a glitch but just renmae the file and changeg it here and tat solve the issuue

# check df or df values
#df
#df["value"].values

# Ensures reproducibility of random numbers
rng = np.random.default_rng(123)

# Build a dataset
#df = pd.DataFrame({
#    "name": [f"Author {i}" for i in range(1, 51)],
#    "value": rng.integers(low=30, high=100, size=50),
#    "group": ["1971-1985"] * 10 + ["1985-2000"] * 20 + ["2000-2010"] * 12 + ["2010-2022"] * 8
#})

# Show 3 first rows
#df["value"].values
#df

def get_label_rotation(angle, offset):
    # Rotation must be specified in degrees :(
    rotation = np.rad2deg(angle + offset)
    if angle <= np.pi:
        alignment = "right"
        rotation = rotation + 180
    else:
        alignment = "left"
    return rotation, alignment

def add_labels(angles, values, labels, offset, ax):

    # This is the space between the end of the bar and the label
    padding = 4

    # Iterate over angles, values, and labels, to add all of them.
    for angle, value, label, in zip(angles, values, labels):
        angle = angle

        # Obtain text rotation and alignment
        rotation, alignment = get_label_rotation(angle, offset)

        # And finally add the text
        ax.text(
            x=angle,
            y=value + padding,
            s=label,
            ha=alignment,
            va="center",
            rotation=rotation,
            rotation_mode="anchor"
        )

ANGLES = np.linspace(0, 2 * np.pi, len(df), endpoint=False)
VALUES = df["value"].values
LABELS = df["author"].values
#LABELS = df["name"].values

# Determine the width of each bar.
# The circumference is '2 * pi', so we divide that total width over the number of bars.
WIDTH = 2 * np.pi / len(VALUES)

# Determines where to place the first bar.
# By default, matplotlib starts at 0 (the first bar is horizontal)
# but here we say we want to start at pi/2 (90 deg)
OFFSET = np.pi / 2

# Initialize Figure and Axis
fig, ax = plt.subplots(figsize=(20, 10), subplot_kw={"projection": "polar"})

# Specify offset
ax.set_theta_offset(OFFSET)


# Set limits for radial (y) axis. The negative lower bound creates the whole in the middle.
ax.set_ylim(-100, 100)

# Remove all spines
ax.set_frame_on(False)

# Remove grid and tick marks
ax.xaxis.grid(False)
ax.yaxis.grid(False)
ax.set_xticks([])
ax.set_yticks([])

# Add bars
ax.bar(
    ANGLES, VALUES, width=WIDTH, linewidth=2,
    color="#61a4b2", edgecolor="white"
)

# Add labels
add_labels(ANGLES, VALUES, LABELS, OFFSET, ax)

# 3 empty bars are added
PAD = 3
ANGLES_N = len(VALUES) + PAD
ANGLES = np.linspace(0, 2 * np.pi, num=ANGLES_N, endpoint=False)
WIDTH = (2 * np.pi) / len(ANGLES)

# The index contains non-empty bards
IDXS = slice(0, ANGLES_N - PAD)

# The layout customization is the same as above
fig, ax = plt.subplots(figsize=(20, 10), subplot_kw={"projection": "polar"})

ax.set_theta_offset(OFFSET)
ax.set_ylim(-100, 100)
ax.set_frame_on(False)
ax.xaxis.grid(False)
ax.yaxis.grid(False)
ax.set_xticks([])
ax.set_yticks([])

# Add bars, subsetting angles to use only those that correspond to non-empty bars
ax.bar(
    ANGLES[IDXS], VALUES, width=WIDTH, color="#61a4b2",
    edgecolor="white", linewidth=2
)

add_labels(ANGLES[IDXS], VALUES, LABELS, OFFSET, ax)

# Grab the group values
GROUP = df["group"].values

# Add three empty bars to the end of each group
PAD = 3
ANGLES_N = len(VALUES) + PAD * len(np.unique(GROUP))
ANGLES = np.linspace(0, 2 * np.pi, num=ANGLES_N, endpoint=False)
WIDTH = (2 * np.pi) / len(ANGLES)

# Obtaining the right indexes is now a little more complicated
offset = 0
IDXS = []
GROUPS_SIZE = [5, 2, 30, 1, 3, 3, 2, 23, 3] #[4, 13, 13, 27]
for size in GROUPS_SIZE:
    IDXS += list(range(offset + PAD, offset + size + PAD))
    offset += size + PAD

# Same layout as above
fig, ax = plt.subplots(figsize=(20, 10), subplot_kw={"projection": "polar"})

ax.set_theta_offset(OFFSET)
ax.set_ylim(-100, 100)
ax.set_frame_on(False)
ax.xaxis.grid(False)
ax.yaxis.grid(False)
ax.set_xticks([])
ax.set_yticks([])


# Use different colors for each group!
GROUPS_SIZE = [5, 2, 30, 1, 3, 3, 2, 23, 3]#[4, 13, 13, 27]
COLORS = [f"C{i}" for i, size in enumerate(GROUPS_SIZE) for _ in range(size)]

# using the loaded data for colors
COLORS = df["barcolors"].values

# And finally add the bars.
# Note again the `ANGLES[IDXS]` to drop some angles that leave the space between bars.
ax.bar(ANGLES[IDXS], VALUES, width=WIDTH, color=COLORS, edgecolor="white", linewidth=2)

add_labels(ANGLES[IDXS], VALUES, LABELS, OFFSET, ax)

# Reorder the dataframe
df_sorted = df #(
    #df
    #.groupby(["group"])
    #.apply(lambda x: x.sort_values(["value"], ascending = False))
    #.reset_index(drop=True)
#)

VALUES = df_sorted["value"].values
#LABELS = df_sorted["name"].values
LABELS = df_sorted["author"].values
GROUP = df_sorted["group"].values

PAD = 3
ANGLES_N = len(VALUES) + PAD * len(np.unique(GROUP))

ANGLES = np.linspace(0, 2 * np.pi, num=ANGLES_N, endpoint=False)
WIDTH = (2 * np.pi) / len(ANGLES)

offset = 0
IDXS = []
for size in GROUPS_SIZE:
    IDXS += list(range(offset + PAD, offset + size + PAD))
    offset += size + PAD

fig, ax = plt.subplots(figsize=(20, 10), subplot_kw={"projection": "polar"})

ax.set_theta_offset(OFFSET)
ax.set_ylim(-100, 100)
ax.set_frame_on(False)
ax.xaxis.grid(False)
ax.yaxis.grid(False)
ax.set_xticks([])
ax.set_yticks([])

GROUPS_SIZE = [5, 2, 30, 1, 3, 3, 2, 23, 3]#[4, 13, 13, 27]
COLORS = [f"C{i}" for i, size in enumerate(GROUPS_SIZE) for _ in range(size)]

# using the loaded data for colors
COLORS = df["barcolors"].values

# Add bars to represent ...
ax.bar(
    ANGLES[IDXS], VALUES, width=WIDTH, color=COLORS,
    edgecolor="white", linewidth=2
)

add_labels(ANGLES[IDXS], VALUES, LABELS, OFFSET, ax)

# All this part is like the code above
VALUES = df["value"].values
#LABELS = df["name"].values
LABELS = df_sorted["author"].values
GROUP = df["group"].values

PAD = 3
ANGLES_N = len(VALUES) + PAD * len(np.unique(GROUP))
ANGLES = np.linspace(0, 2 * np.pi, num=ANGLES_N, endpoint=False)
WIDTH = (2 * np.pi) / len(ANGLES)

offset = 0
IDXS = []
GROUPS_SIZE = [5, 2, 30, 1, 3, 3, 2, 23, 3]#[4, 13, 13, 27]
for size in GROUPS_SIZE:
    IDXS += list(range(offset + PAD, offset + size + PAD))
    offset += size + PAD

fig, ax = plt.subplots(figsize=(20, 10), subplot_kw={"projection": "polar"})
ax.set_theta_offset(OFFSET)
ax.set_ylim(-100, 100)
ax.set_frame_on(False)
ax.xaxis.grid(False)
ax.yaxis.grid(False)
ax.set_xticks([])
ax.set_yticks([])



GROUPS_SIZE = [5, 2, 30, 1, 3, 3, 2, 23, 3]#[4, 13, 13, 27]
COLORS = [f"C{i}" for i, size in enumerate(GROUPS_SIZE) for _ in range(size)]

# using the loaded data for colors
COLORS = df["barcolors"].values

ax.bar(
    ANGLES[IDXS], VALUES, width=WIDTH, color=COLORS,
    edgecolor="white", linewidth=2
)

add_labels(ANGLES[IDXS], VALUES, LABELS, OFFSET, ax)



# Extra customization below here --------------------

# This iterates over the sizes of the groups adding reference
# lines and annotations.

offset = 0
#for group, size in zip(["1971-1985", "1985-2000", "2000-2010", "2010-2022"], GROUPS_SIZE):
for group, size in zip(["1", "2", "3", "4","5","6","7","8","9"], GROUPS_SIZE):
    # Add line below bars
    x1 = np.linspace(ANGLES[offset + PAD], ANGLES[offset + size + PAD - 1], num=50)
    ax.plot(x1, [-5] * 50, color="#333333")

    # Add text to indicate group
    ax.text(
        np.mean(x1), -20, group, color="#333333", fontsize=14,
        fontweight="bold", ha="center", va="center"
    )



    # Add reference lines at 20, 40, 60, and 80
    x2 = np.linspace(ANGLES[offset], ANGLES[offset + PAD - 1], num=50)
    ax.plot(x2, [20] * 50, color="#bebebe", lw=0.8)
    ax.plot(x2, [40] * 50, color="#bebebe", lw=0.8)
    ax.plot(x2, [60] * 50, color="#bebebe", lw=0.8)
    ax.plot(x2, [80] * 50, color="#bebebe", lw=0.8)


    offset += size + PAD


plt.savefig("LRMechConfig_PaperFig_FontSize16.pdf", bbox_inches='tight',format='pdf')
files.download("LRMechConfig_PaperFig_FontSize16.pdf")

#image_format = 'svg' # e.g .png, .svg, etc.
#image_name = 'myimage.svg'

#fig.savefig(image_name, format=image_format, dpi=1200)

